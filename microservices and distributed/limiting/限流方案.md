## 通过`Redis Key`限流

lua脚本：

```lua
local key = KEYS[1] --限流KEY（一秒一个）
local limit = tonumber(ARGV[1])        --限流大小
local current = tonumber(redis.call("INCRBY", key, "1")) --请求数+1
if current > limit then --如果超出限流大小
   return 0
elseif current == 1 then  --只有第一次访问需要设置2秒的过期时间
   redis.call("expire", key,"2")
end
return 1
```


如上操作因是在一个lua脚本中，又因Redis是单线程模型，因此是线程安全的。如上方式有一个缺点就是当达到限流大小后还是会递增的，可以改造成如下方式实现：

```lua
local key = KEYS[1] --限流KEY（一秒一个）
local limit = tonumber(ARGV[1])        --限流大小
local current = tonumber(redis.call('get', key) or "0")
if current + 1 > limit then --如果超出限流大小
   return 0
else  --请求数+1，并设置2秒过期
   redis.call("INCRBY", key,"1")
   redis.call("expire", key,"2")
   return 1
end
```


如下是Java中判断是否需要限流的代码：

```java
public static boolean acquire() throws Exception {
    String luaScript = Files.toString(new File("limit.lua"), 		 Charset.defaultCharset());
    Jedis jedis = new Jedis("192.168.20.128", 6379);
    String key = "test_limit:" + System.currentTimeMillis()/ 1000; //此处将当前时间戳取秒数
    Stringlimit = "5"; //限流大小
    return (Long)jedis.eval(luaScript,Lists.newArrayList(key), Lists.newArrayList(limit)) == 1;
}
```

因为Redis的限制（Lua中有写操作不能使用带随机性质的读操作，如TIME）不能在Redis Lua中使用TIME获取时间戳，因此只好从应用获取然后传入，在某些极端情况下（机器时钟不准的情况下），限流会存在一些小问题。
这样写仅是demo写法，调用每次都从文件中读取性能开销还是很大的，实际项目中应用的时候InitializingBean或者其他形式在项目启动的时候加载进来，当然也可以通过zookeeper加载在系统中用watch监听，变更重新加载。手段很多，这里不多说了。。。

## redis令牌桶

大家有没有发现，上面这种写法还是缺陷的，就是所谓的计数器限流，不平滑，没法应对突发的峰值，所以借鉴RateLimiter的做法，用redis做令牌桶限流

lua脚本

```lua
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zgl.
--- DateTime: 2018-10-29 16:54
--- 返回结果为0—未获得令牌，1—已获得令牌
--- hmap结构 [lastTimestamp,tokensRemaining]
local key = KEYS[1]   -- 限流的redis key值
local currentTimestamp = tonumber(ARGV[1])  -- 当前时间戳
local limit = tonumber(ARGV[2]) -- 间隔时间生成令牌的个数
local interval = tonumber(ARGV[3])  -- 桶的限流间隔
local intervalPerTokenTime = math.floor(interval/limit);   -- 生成令牌的间隔时间
local counter = redis.call('hgetall', key)
 
if table.getn(counter) == 0 then
    -- 如果桶不存在则先设置key,可用令牌数=limit-1，并返回1
    redis.call('hmset', key, 'lastTimestamp', currentTimestamp, 'tokensRemaining', limit - 1)
    redis.call('pexpire', key, interval) --设置过期时间
    return 1
elseif table.getn(counter) == 4 then
    -- 如果桶存在则获取值
    local lastTimestamp, tokensRemaining = tonumber(counter[2]), tonumber(counter[4])
    local currentTokens
    if currentTimestamp > lastTimestamp then
        -- 校验当前时间是否大于最后一次获取时间
        local intervalSinceLastTime = currentTimestamp - lastTimestamp
        if intervalSinceLastTime > interval then
            currentTokens = limit
            redis.call('hset', key, 'lastTimestamp', currentTimestamp)  --更为新当前时间
        else
            local grantedTokens = math.floor(intervalSinceLastTime / intervalPerTokenTime)
            if grantedTokens > 0 then
                local padMillis = math.fmod(intervalSinceLastTime, intervalPerTokenTime)
                redis.call('hset', key, 'lastRefillTime', currentTimestamp - padMillis)
            end
            currentTokens = math.min(grantedTokens + tokensRemaining, limit)
        end
    else
        currentTokens = tokensRemaining
    end
    assert(currentTokens >= 0)
    if currentTokens == 0 then
        -- 不能获取令牌
        redis.call('hset', key, 'tokensRemaining', currentTokens)
        return 0
    else
        -- 从桶里面拿到一个令牌
        redis.call('hset', key, 'tokensRemaining', currentTokens - 1)
        return 1
    end
else
    error("Size of counter is " .. table.getn(counter) .. ", Should Be 0 or 4.")
end
```


java应用直接传key和三个参数

- currentTimestamp：当前获取的时间戳
- limit：间隔时间产生令牌的个数
- interval： 生成令牌的间隔时间，一般默认1000（毫秒）

细节上还有写问题，比如精确到毫秒的，当并发大于毫秒的精度时的处理都还没有考虑
这样虽然实现了令牌桶的限流，但只是相当于RateLimiter中tryAcquire()方法，没有实现延迟的功能，延迟复杂了点，先这样吧，有机会在优化。。。

```java
public boolean tryAcquire(List<String> keys, List<String> args) {
    Jedis jedis = new Jedis(ip,port);
    return (Long)jedis.eval(LuaUtils.getTokenBucketScript(),keys, args) == 1;
}

@RequestMapping("/hi")
public String home(@RequestParam String name) {
   String limit = "10";
   String currentTimestamp = String.valueOf(System.currentTimeMillis());
   String interval = "1000";
   boolean flag = this.limitService.tryAcquire(Lists.newArrayList(name),Lists.newArrayList(currentTimestamp,limit,interval));
   if(flag){
      return "true";
   }else{
      return "false";
   }
}
```